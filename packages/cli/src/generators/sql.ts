/**
 * SQL Schema Generator
 *
 * Generates raw SQL schema files from OpenMDM core schema.
 */

import {
  mdmSchema,
  type ColumnDefinition,
  type TableDefinition,
  type IndexDefinition,
} from '@openmdm/core/schema';
import type { DatabaseProvider } from './index.js';

interface SqlGeneratorOptions {
  provider: DatabaseProvider;
  tablePrefix?: string;
}

/**
 * Generate raw SQL schema
 */
export function generateSqlSchema(options: SqlGeneratorOptions): string {
  const { provider, tablePrefix = '' } = options;

  switch (provider) {
    case 'pg':
      return generatePostgresSchema(tablePrefix);
    case 'mysql':
      return generateMysqlSchema(tablePrefix);
    case 'sqlite':
      return generateSqliteSchema(tablePrefix);
  }
}

function generatePostgresSchema(tablePrefix: string): string {
  const lines: string[] = [
    '-- OpenMDM PostgreSQL Schema',
    '-- Generated by @openmdm/cli - Do not edit manually.',
    '-- Regenerate with: npx openmdm generate --adapter sql --provider pg',
    '',
  ];

  // Generate enums
  const enums = collectEnums();
  for (const [name, values] of enums) {
    const enumName = applyPrefix(name, tablePrefix);
    lines.push(`DO $$ BEGIN`);
    lines.push(`    CREATE TYPE "${enumName}" AS ENUM (${values.map((v) => `'${v}'`).join(', ')});`);
    lines.push(`EXCEPTION`);
    lines.push(`    WHEN duplicate_object THEN null;`);
    lines.push(`END $$;`);
    lines.push('');
  }

  // Generate tables
  for (const [tableName, table] of Object.entries(mdmSchema.tables)) {
    lines.push(generatePostgresTable(tableName, table, tablePrefix));
    lines.push('');

    // Generate indexes
    if (table.indexes) {
      for (const idx of table.indexes) {
        lines.push(generatePostgresIndex(tableName, idx, tablePrefix));
      }
      lines.push('');
    }
  }

  return lines.join('\n');
}

function generatePostgresTable(
  tableName: string,
  table: TableDefinition,
  tablePrefix: string
): string {
  const dbTableName = applyPrefix(tableName, tablePrefix);
  const columns: string[] = [];
  const constraints: string[] = [];

  for (const [colName, col] of Object.entries(table.columns)) {
    columns.push(generatePostgresColumn(colName, col, tableName, tablePrefix));

    // Collect FK constraints
    if (col.references) {
      const refTable = applyPrefix(col.references.table, tablePrefix);
      const onDelete = col.references.onDelete?.toUpperCase() || 'RESTRICT';
      constraints.push(
        `    CONSTRAINT "fk_${dbTableName}_${colName}" FOREIGN KEY ("${colName}") REFERENCES "${refTable}"("${col.references.column}") ON DELETE ${onDelete.replace('_', ' ')}`
      );
    }
  }

  // Find composite primary key (for junction tables)
  const pkCols = Object.entries(table.columns)
    .filter(([_, col]) => col.primaryKey)
    .map(([name]) => `"${name}"`);

  if (pkCols.length === 0) {
    // Check for unique index that could be a composite PK
    const uniqueIdx = table.indexes?.find((idx) => idx.unique && idx.columns.length > 1);
    if (uniqueIdx) {
      constraints.push(
        `    PRIMARY KEY (${uniqueIdx.columns.map((c) => `"${c}"`).join(', ')})`
      );
    }
  }

  const allParts = [...columns, ...constraints];

  return `CREATE TABLE IF NOT EXISTS "${dbTableName}" (
${allParts.join(',\n')}
);`;
}

function generatePostgresColumn(
  colName: string,
  col: ColumnDefinition,
  tableName: string,
  tablePrefix: string
): string {
  let type = '';

  switch (col.type) {
    case 'string':
      type = 'varchar(255)';
      break;
    case 'text':
      type = 'text';
      break;
    case 'integer':
      type = 'integer';
      break;
    case 'bigint':
      type = 'bigint';
      break;
    case 'boolean':
      type = 'boolean';
      break;
    case 'datetime':
      type = 'timestamp with time zone';
      break;
    case 'json':
      type = 'json';
      break;
    case 'enum':
      type = `"${applyPrefix(`${tableName}_${colName}`, tablePrefix)}"`;
      break;
  }

  let def = `    "${colName}" ${type}`;

  if (col.primaryKey) {
    def += ' PRIMARY KEY';
  }
  if (col.unique) {
    def += ' UNIQUE';
  }
  if (!col.nullable && !col.primaryKey) {
    def += ' NOT NULL';
  }
  if (col.default !== undefined) {
    if (col.default === 'now') {
      def += ' DEFAULT now()';
    } else if (typeof col.default === 'boolean') {
      def += ` DEFAULT ${col.default}`;
    } else if (typeof col.default === 'number') {
      def += ` DEFAULT ${col.default}`;
    } else if (typeof col.default === 'string') {
      def += ` DEFAULT '${col.default}'`;
    }
  }

  return def;
}

function generatePostgresIndex(
  tableName: string,
  idx: IndexDefinition,
  tablePrefix: string
): string {
  const dbTableName = applyPrefix(tableName, tablePrefix);
  const idxName = idx.name || `idx_${dbTableName}_${idx.columns.join('_')}`;
  const cols = idx.columns.map((c) => `"${c}"`).join(', ');
  const unique = idx.unique ? 'UNIQUE ' : '';

  return `CREATE ${unique}INDEX IF NOT EXISTS "${idxName}" ON "${dbTableName}" (${cols});`;
}

function generateMysqlSchema(tablePrefix: string): string {
  const lines: string[] = [
    '-- OpenMDM MySQL Schema',
    '-- Generated by @openmdm/cli - Do not edit manually.',
    '-- Regenerate with: npx openmdm generate --adapter sql --provider mysql',
    '',
  ];

  // Generate tables
  for (const [tableName, table] of Object.entries(mdmSchema.tables)) {
    lines.push(generateMysqlTable(tableName, table, tablePrefix));
    lines.push('');
  }

  return lines.join('\n');
}

function generateMysqlTable(
  tableName: string,
  table: TableDefinition,
  tablePrefix: string
): string {
  const dbTableName = applyPrefix(tableName, tablePrefix);
  const columns: string[] = [];
  const constraints: string[] = [];
  const indexes: string[] = [];

  for (const [colName, col] of Object.entries(table.columns)) {
    columns.push(generateMysqlColumn(colName, col, tableName));

    // Collect FK constraints
    if (col.references) {
      const refTable = applyPrefix(col.references.table, tablePrefix);
      const onDelete = col.references.onDelete?.toUpperCase() || 'RESTRICT';
      constraints.push(
        `    CONSTRAINT \`fk_${dbTableName}_${colName}\` FOREIGN KEY (\`${colName}\`) REFERENCES \`${refTable}\`(\`${col.references.column}\`) ON DELETE ${onDelete.replace('_', ' ')}`
      );
    }
  }

  // Generate indexes
  if (table.indexes) {
    for (const idx of table.indexes) {
      const idxName = idx.name || `idx_${dbTableName}_${idx.columns.join('_')}`;
      const cols = idx.columns.map((c) => `\`${c}\``).join(', ');
      const unique = idx.unique ? 'UNIQUE ' : '';
      indexes.push(`    ${unique}INDEX \`${idxName}\` (${cols})`);
    }
  }

  const allParts = [...columns, ...constraints, ...indexes];

  return `CREATE TABLE IF NOT EXISTS \`${dbTableName}\` (
${allParts.join(',\n')}
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;`;
}

function generateMysqlColumn(
  colName: string,
  col: ColumnDefinition,
  tableName: string
): string {
  let type = '';

  switch (col.type) {
    case 'string':
      type = 'VARCHAR(255)';
      break;
    case 'text':
      type = 'TEXT';
      break;
    case 'integer':
      type = 'INT';
      break;
    case 'bigint':
      type = 'BIGINT';
      break;
    case 'boolean':
      type = 'BOOLEAN';
      break;
    case 'datetime':
      type = 'TIMESTAMP';
      break;
    case 'json':
      type = 'JSON';
      break;
    case 'enum':
      type = `ENUM(${col.enumValues?.map((v) => `'${v}'`).join(', ')})`;
      break;
  }

  let def = `    \`${colName}\` ${type}`;

  if (col.primaryKey) {
    def += ' PRIMARY KEY';
  }
  if (col.unique) {
    def += ' UNIQUE';
  }
  if (!col.nullable && !col.primaryKey) {
    def += ' NOT NULL';
  }
  if (col.default !== undefined) {
    if (col.default === 'now') {
      def += ' DEFAULT CURRENT_TIMESTAMP';
    } else if (typeof col.default === 'boolean') {
      def += ` DEFAULT ${col.default}`;
    } else if (typeof col.default === 'number') {
      def += ` DEFAULT ${col.default}`;
    } else if (typeof col.default === 'string') {
      def += ` DEFAULT '${col.default}'`;
    }
  }

  return def;
}

function generateSqliteSchema(tablePrefix: string): string {
  const lines: string[] = [
    '-- OpenMDM SQLite Schema',
    '-- Generated by @openmdm/cli - Do not edit manually.',
    '-- Regenerate with: npx openmdm generate --adapter sql --provider sqlite',
    '',
  ];

  // Generate tables
  for (const [tableName, table] of Object.entries(mdmSchema.tables)) {
    lines.push(generateSqliteTable(tableName, table, tablePrefix));
    lines.push('');

    // Generate indexes
    if (table.indexes) {
      for (const idx of table.indexes) {
        lines.push(generateSqliteIndex(tableName, idx, tablePrefix));
      }
      lines.push('');
    }
  }

  return lines.join('\n');
}

function generateSqliteTable(
  tableName: string,
  table: TableDefinition,
  tablePrefix: string
): string {
  const dbTableName = applyPrefix(tableName, tablePrefix);
  const columns: string[] = [];
  const constraints: string[] = [];

  for (const [colName, col] of Object.entries(table.columns)) {
    columns.push(generateSqliteColumn(colName, col));

    // Collect FK constraints
    if (col.references) {
      const refTable = applyPrefix(col.references.table, tablePrefix);
      const onDelete = col.references.onDelete?.toUpperCase() || 'RESTRICT';
      constraints.push(
        `    FOREIGN KEY ("${colName}") REFERENCES "${refTable}"("${col.references.column}") ON DELETE ${onDelete.replace('_', ' ')}`
      );
    }
  }

  // Find composite primary key
  const uniqueIdx = table.indexes?.find((idx) => idx.unique && idx.columns.length > 1);
  if (uniqueIdx) {
    const hasSinglePk = Object.values(table.columns).some((c) => c.primaryKey);
    if (!hasSinglePk) {
      constraints.push(
        `    PRIMARY KEY (${uniqueIdx.columns.map((c) => `"${c}"`).join(', ')})`
      );
    }
  }

  const allParts = [...columns, ...constraints];

  return `CREATE TABLE IF NOT EXISTS "${dbTableName}" (
${allParts.join(',\n')}
);`;
}

function generateSqliteColumn(colName: string, col: ColumnDefinition): string {
  let type = '';

  switch (col.type) {
    case 'string':
    case 'text':
    case 'enum':
      type = 'TEXT';
      break;
    case 'integer':
    case 'bigint':
    case 'boolean':
      type = 'INTEGER';
      break;
    case 'datetime':
      type = 'INTEGER'; // Store as Unix timestamp
      break;
    case 'json':
      type = 'TEXT'; // JSON stored as text
      break;
  }

  let def = `    "${colName}" ${type}`;

  if (col.primaryKey) {
    def += ' PRIMARY KEY';
  }
  if (col.unique) {
    def += ' UNIQUE';
  }
  if (!col.nullable && !col.primaryKey) {
    def += ' NOT NULL';
  }
  if (col.default !== undefined) {
    if (col.default === 'now') {
      def += ` DEFAULT (cast(unixepoch('subsecond') * 1000 as integer))`;
    } else if (typeof col.default === 'boolean') {
      def += ` DEFAULT ${col.default ? 1 : 0}`;
    } else if (typeof col.default === 'number') {
      def += ` DEFAULT ${col.default}`;
    } else if (typeof col.default === 'string') {
      def += ` DEFAULT '${col.default}'`;
    }
  }

  return def;
}

function generateSqliteIndex(
  tableName: string,
  idx: IndexDefinition,
  tablePrefix: string
): string {
  const dbTableName = applyPrefix(tableName, tablePrefix);
  const idxName = idx.name || `idx_${dbTableName}_${idx.columns.join('_')}`;
  const cols = idx.columns.map((c) => `"${c}"`).join(', ');
  const unique = idx.unique ? 'UNIQUE ' : '';

  return `CREATE ${unique}INDEX IF NOT EXISTS "${idxName}" ON "${dbTableName}" (${cols});`;
}

function collectEnums(): Map<string, string[]> {
  const enums: Map<string, string[]> = new Map();

  for (const [tableName, table] of Object.entries(mdmSchema.tables)) {
    for (const [colName, col] of Object.entries(table.columns)) {
      if (col.type === 'enum' && col.enumValues) {
        const enumName = `${tableName}_${colName}`;
        enums.set(enumName, col.enumValues);
      }
    }
  }

  return enums;
}

function applyPrefix(name: string, prefix: string): string {
  if (!prefix) return name;
  return `${prefix}_${name}`;
}
