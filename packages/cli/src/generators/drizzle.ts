/**
 * Drizzle Schema Generator
 *
 * Generates Drizzle ORM schema files from OpenMDM core schema.
 */

import {
  mdmSchema,
  type ColumnDefinition,
  type TableDefinition,
  type IndexDefinition,
} from '@openmdm/core/schema';
import type { DatabaseProvider } from './index.js';

interface DrizzleGeneratorOptions {
  provider: DatabaseProvider;
  tablePrefix?: string;
}

/**
 * Generate Drizzle schema TypeScript code
 */
export function generateDrizzleSchema(options: DrizzleGeneratorOptions): string {
  const { provider, tablePrefix = '' } = options;

  const imports = generateImports(provider);
  const enums = generateEnums(provider, tablePrefix);
  const tables = generateTables(provider, tablePrefix);
  const relations = generateRelations(tablePrefix);

  return `${imports}

${enums}

${tables}

${relations}

// Export all tables for easy schema setup
export const mdmSchema = {
${Object.keys(mdmSchema.tables)
  .map((name) => `  ${toCamelCase(applyPrefix(name, tablePrefix))},`)
  .join('\n')}
};
`;
}

function generateImports(provider: DatabaseProvider): string {
  switch (provider) {
    case 'pg':
      return `/**
 * OpenMDM Drizzle Schema for PostgreSQL
 *
 * Generated by @openmdm/cli - Do not edit manually.
 * Regenerate with: npx openmdm generate --adapter drizzle --provider pg
 */

import {
  pgTable,
  pgEnum,
  text,
  varchar,
  boolean,
  integer,
  bigint,
  timestamp,
  json,
  index,
  uniqueIndex,
  primaryKey,
} from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';`;

    case 'mysql':
      return `/**
 * OpenMDM Drizzle Schema for MySQL
 *
 * Generated by @openmdm/cli - Do not edit manually.
 * Regenerate with: npx openmdm generate --adapter drizzle --provider mysql
 */

import {
  mysqlTable,
  mysqlEnum,
  text,
  varchar,
  boolean,
  int,
  bigint,
  timestamp,
  json,
  index,
  uniqueIndex,
  primaryKey,
} from 'drizzle-orm/mysql-core';
import { relations } from 'drizzle-orm';`;

    case 'sqlite':
      return `/**
 * OpenMDM Drizzle Schema for SQLite
 *
 * Generated by @openmdm/cli - Do not edit manually.
 * Regenerate with: npx openmdm generate --adapter drizzle --provider sqlite
 */

import {
  sqliteTable,
  text,
  integer,
  blob,
  index,
  uniqueIndex,
  primaryKey,
} from 'drizzle-orm/sqlite-core';
import { relations, sql } from 'drizzle-orm';`;
  }
}

function generateEnums(provider: DatabaseProvider, tablePrefix: string): string {
  // Collect all enums from schema
  const enums: Map<string, string[]> = new Map();

  for (const [tableName, table] of Object.entries(mdmSchema.tables)) {
    for (const [colName, col] of Object.entries(table.columns)) {
      if (col.type === 'enum' && col.enumValues) {
        const enumName = `${tableName}_${colName}`;
        enums.set(enumName, col.enumValues);
      }
    }
  }

  if (enums.size === 0) return '';

  const enumDefs: string[] = [];

  for (const [name, values] of enums) {
    const enumVarName = toCamelCase(applyPrefix(name, tablePrefix)) + 'Enum';
    const enumDbName = applyPrefix(name, tablePrefix);

    switch (provider) {
      case 'pg':
        enumDefs.push(
          `export const ${enumVarName} = pgEnum('${enumDbName}', [${values.map((v) => `'${v}'`).join(', ')}]);`
        );
        break;
      case 'mysql':
        enumDefs.push(
          `export const ${enumVarName} = mysqlEnum('${enumDbName}', [${values.map((v) => `'${v}'`).join(', ')}]);`
        );
        break;
      case 'sqlite':
        // SQLite doesn't have native enums, we use text with CHECK constraint
        enumDefs.push(
          `// SQLite enum values for ${enumVarName}: ${values.map((v) => `'${v}'`).join(', ')}`
        );
        break;
    }
  }

  return `// ============================================
// Enums
// ============================================

${enumDefs.join('\n\n')}`;
}

function generateTables(provider: DatabaseProvider, tablePrefix: string): string {
  const tableDefs: string[] = [];

  for (const [tableName, table] of Object.entries(mdmSchema.tables)) {
    tableDefs.push(generateTable(tableName, table, provider, tablePrefix));
  }

  return `// ============================================
// Tables
// ============================================

${tableDefs.join('\n\n')}`;
}

function generateTable(
  tableName: string,
  table: TableDefinition,
  provider: DatabaseProvider,
  tablePrefix: string
): string {
  const varName = toCamelCase(applyPrefix(tableName, tablePrefix));
  const dbTableName = applyPrefix(tableName, tablePrefix);
  const tableFunc = getTableFunc(provider);

  const columns = Object.entries(table.columns)
    .map(([colName, col]) => generateColumn(colName, col, tableName, provider, tablePrefix))
    .join(',\n    ');

  const indexes = table.indexes
    ? generateIndexes(table.indexes, varName, provider)
    : '';

  return `export const ${varName} = ${tableFunc}(
  '${dbTableName}',
  {
    ${columns}
  }${indexes ? `,\n  (table) => [\n${indexes}\n  ]` : ''}
);`;
}

function generateColumn(
  colName: string,
  col: ColumnDefinition,
  tableName: string,
  provider: DatabaseProvider,
  tablePrefix: string
): string {
  const camelColName = toCamelCase(colName);
  let colDef = '';

  switch (provider) {
    case 'pg':
      colDef = generatePgColumn(colName, col, tableName, tablePrefix);
      break;
    case 'mysql':
      colDef = generateMysqlColumn(colName, col, tableName, tablePrefix);
      break;
    case 'sqlite':
      colDef = generateSqliteColumn(colName, col, tableName, tablePrefix);
      break;
  }

  return `${camelColName}: ${colDef}`;
}

function generatePgColumn(
  colName: string,
  col: ColumnDefinition,
  tableName: string,
  tablePrefix: string
): string {
  let def = '';

  switch (col.type) {
    case 'string':
      def = `varchar('${colName}', { length: 255 })`;
      break;
    case 'text':
      def = `text('${colName}')`;
      break;
    case 'integer':
      def = `integer('${colName}')`;
      break;
    case 'bigint':
      def = `bigint('${colName}', { mode: 'number' })`;
      break;
    case 'boolean':
      def = `boolean('${colName}')`;
      break;
    case 'datetime':
      def = `timestamp('${colName}', { withTimezone: true })`;
      break;
    case 'json':
      def = `json('${colName}')`;
      break;
    case 'enum':
      const enumVarName = toCamelCase(applyPrefix(`${tableName}_${colName}`, tablePrefix)) + 'Enum';
      def = `${enumVarName}('${colName}')`;
      break;
  }

  // Add constraints
  if (col.primaryKey) {
    def += '.primaryKey()';
  }
  if (col.unique) {
    def += '.unique()';
  }
  if (!col.nullable && !col.primaryKey) {
    def += '.notNull()';
  }
  if (col.default !== undefined) {
    if (col.default === 'now') {
      def += '.defaultNow()';
    } else if (typeof col.default === 'boolean') {
      def += `.default(${col.default})`;
    } else if (typeof col.default === 'number') {
      def += `.default(${col.default})`;
    } else if (typeof col.default === 'string') {
      def += `.default('${col.default}')`;
    }
  }

  // Add foreign key reference
  if (col.references) {
    const refTable = toCamelCase(applyPrefix(col.references.table, tablePrefix));
    const onDelete = col.references.onDelete || 'restrict';
    def += `.references(() => ${refTable}.${toCamelCase(col.references.column)}, { onDelete: '${onDelete}' })`;
  }

  return def;
}

function generateMysqlColumn(
  colName: string,
  col: ColumnDefinition,
  tableName: string,
  tablePrefix: string
): string {
  let def = '';

  switch (col.type) {
    case 'string':
      def = `varchar('${colName}', { length: 255 })`;
      break;
    case 'text':
      def = `text('${colName}')`;
      break;
    case 'integer':
      def = `int('${colName}')`;
      break;
    case 'bigint':
      def = `bigint('${colName}', { mode: 'number' })`;
      break;
    case 'boolean':
      def = `boolean('${colName}')`;
      break;
    case 'datetime':
      def = `timestamp('${colName}')`;
      break;
    case 'json':
      def = `json('${colName}')`;
      break;
    case 'enum':
      const enumVarName = toCamelCase(applyPrefix(`${tableName}_${colName}`, tablePrefix)) + 'Enum';
      def = `${enumVarName}('${colName}')`;
      break;
  }

  // Add constraints
  if (col.primaryKey) {
    def += '.primaryKey()';
  }
  if (col.unique) {
    def += '.unique()';
  }
  if (!col.nullable && !col.primaryKey) {
    def += '.notNull()';
  }
  if (col.default !== undefined) {
    if (col.default === 'now') {
      def += '.defaultNow()';
    } else if (typeof col.default === 'boolean') {
      def += `.default(${col.default})`;
    } else if (typeof col.default === 'number') {
      def += `.default(${col.default})`;
    } else if (typeof col.default === 'string') {
      def += `.default('${col.default}')`;
    }
  }

  // Add foreign key reference
  if (col.references) {
    const refTable = toCamelCase(applyPrefix(col.references.table, tablePrefix));
    const onDelete = col.references.onDelete || 'restrict';
    def += `.references(() => ${refTable}.${toCamelCase(col.references.column)}, { onDelete: '${onDelete}' })`;
  }

  return def;
}

function generateSqliteColumn(
  colName: string,
  col: ColumnDefinition,
  tableName: string,
  tablePrefix: string
): string {
  let def = '';

  switch (col.type) {
    case 'string':
    case 'text':
    case 'enum':
      def = `text('${colName}')`;
      break;
    case 'integer':
    case 'bigint':
      def = `integer('${colName}')`;
      break;
    case 'boolean':
      def = `integer('${colName}', { mode: 'boolean' })`;
      break;
    case 'datetime':
      def = `integer('${colName}', { mode: 'timestamp_ms' })`;
      break;
    case 'json':
      def = `text('${colName}', { mode: 'json' })`;
      break;
  }

  // Add constraints
  if (col.primaryKey) {
    def += '.primaryKey()';
  }
  if (col.unique) {
    def += '.unique()';
  }
  if (!col.nullable && !col.primaryKey) {
    def += '.notNull()';
  }
  if (col.default !== undefined) {
    if (col.default === 'now') {
      def += `.default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)`;
    } else if (typeof col.default === 'boolean') {
      def += `.default(${col.default})`;
    } else if (typeof col.default === 'number') {
      def += `.default(${col.default})`;
    } else if (typeof col.default === 'string') {
      def += `.default('${col.default}')`;
    }
  }

  // Add foreign key reference
  if (col.references) {
    const refTable = toCamelCase(applyPrefix(col.references.table, tablePrefix));
    const onDelete = col.references.onDelete || 'restrict';
    def += `.references(() => ${refTable}.${toCamelCase(col.references.column)}, { onDelete: '${onDelete}' })`;
  }

  return def;
}

function generateIndexes(
  indexes: IndexDefinition[],
  tableVarName: string,
  provider: DatabaseProvider
): string {
  return indexes
    .map((idx) => {
      const cols = idx.columns.map((c) => `table.${toCamelCase(c)}`).join(', ');
      const idxName = idx.name || `${tableVarName}_${idx.columns.join('_')}_idx`;

      if (idx.unique) {
        return `    uniqueIndex('${idxName}').on(${cols})`;
      }
      return `    index('${idxName}').on(${cols})`;
    })
    .join(',\n');
}

function generateRelations(tablePrefix: string): string {
  // Generate Drizzle relations based on foreign keys
  const relations: string[] = [];

  for (const [tableName, table] of Object.entries(mdmSchema.tables)) {
    const varName = toCamelCase(applyPrefix(tableName, tablePrefix));
    const fks: { colName: string; refTable: string; refCol: string }[] = [];
    const reverseRefs: { fromTable: string; fromCol: string }[] = [];

    // Find foreign keys in this table
    for (const [colName, col] of Object.entries(table.columns)) {
      if (col.references) {
        fks.push({
          colName,
          refTable: col.references.table,
          refCol: col.references.column,
        });
      }
    }

    // Find tables that reference this table
    for (const [otherTableName, otherTable] of Object.entries(mdmSchema.tables)) {
      if (otherTableName === tableName) continue;
      for (const [otherColName, otherCol] of Object.entries(otherTable.columns)) {
        if (otherCol.references?.table === tableName) {
          reverseRefs.push({
            fromTable: otherTableName,
            fromCol: otherColName,
          });
        }
      }
    }

    if (fks.length === 0 && reverseRefs.length === 0) continue;

    const relationParts: string[] = [];

    // one() relations for foreign keys
    for (const fk of fks) {
      const refTableVar = toCamelCase(applyPrefix(fk.refTable, tablePrefix));
      const colVar = toCamelCase(fk.colName);
      const refColVar = toCamelCase(fk.refCol);
      const relationName = fk.colName.replace(/_id$/, '');

      relationParts.push(
        `  ${toCamelCase(relationName)}: one(${refTableVar}, {
    fields: [${varName}.${colVar}],
    references: [${refTableVar}.${refColVar}],
  })`
      );
    }

    // many() relations for reverse references
    for (const ref of reverseRefs) {
      const fromTableVar = toCamelCase(applyPrefix(ref.fromTable, tablePrefix));
      const pluralName = ref.fromTable.replace(/^mdm_/, '');

      relationParts.push(`  ${toCamelCase(pluralName)}: many(${fromTableVar})`);
    }

    if (relationParts.length > 0) {
      relations.push(
        `export const ${varName}Relations = relations(${varName}, ({ one, many }) => ({
${relationParts.join(',\n')}
}));`
      );
    }
  }

  if (relations.length === 0) return '';

  return `// ============================================
// Relations
// ============================================

${relations.join('\n\n')}`;
}

function getTableFunc(provider: DatabaseProvider): string {
  switch (provider) {
    case 'pg':
      return 'pgTable';
    case 'mysql':
      return 'mysqlTable';
    case 'sqlite':
      return 'sqliteTable';
  }
}

function toCamelCase(str: string): string {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

function applyPrefix(name: string, prefix: string): string {
  if (!prefix) return name;
  return `${prefix}_${name}`;
}
